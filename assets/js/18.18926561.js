(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{479:function(e,s,v){"use strict";v.r(s);var _=v(9),t=Object(_.a)({},(function(){var e=this,s=e.$createElement,v=e._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"redis"}},[e._v("redis")]),e._v(" "),v("p",[e._v("Redis是一种开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超级日志，带有半径查询和流的地理空间索引。Redis具有内置的复制，Lua脚本，LRU逐出，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区提供了高可用性。")]),e._v(" "),v("p",[e._v("博文参考："),v("br"),e._v(" "),v("a",{attrs:{href:"https://www.cnblogs.com/idiotgroup/p/5455282.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.https://www.cnblogs.com/idiotgroup/p/5455282.html"),v("OutboundLink")],1),v("br"),e._v(" "),v("a",{attrs:{href:"https://www.cnblogs.com/kismetv/p/9137897.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.https://www.cnblogs.com/kismetv/p/9137897.html"),v("OutboundLink")],1)]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"一、redis内存统计"}},[e._v("一、Redis内存统计")]),e._v(" "),v("p",[e._v("在客户端通过redis-cli连接服务器后（后面如无特殊说明，客户端一律使用redis-cli），通过info命令可以查看内存使用情况：")]),e._v(" "),v("p",[v("code",[e._v("info memory")])]),e._v(" "),v("h2",{attrs:{id:"二、redis内存划分"}},[e._v("二、Redis内存划分")]),e._v(" "),v("p",[e._v("Redis作为内存数据库，在内存中存储的内容主要是数据（键值对）；通过前面的叙述可以知道，除了数据以外，Redis的其他部分也会占用内存。")]),e._v(" "),v("p",[e._v("Redis的内存占用主要可以划分为以下几个部分：")]),e._v(" "),v("h3",{attrs:{id:"_1、数据"}},[e._v("1、数据")]),e._v(" "),v("p",[e._v("作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。")]),e._v(" "),v("p",[e._v("Redis使用键值对存储数据，其中的值（对象）包括5种类型，即字符串、哈希、列表、集合、有序集合。这5种类型是Redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；这篇文章后面将重点介绍Redis中数据存储的细节。")]),e._v(" "),v("h3",{attrs:{id:"_2、进程本身运行需要的内存"}},[e._v("2、进程本身运行需要的内存")]),e._v(" "),v("p",[e._v("Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。")]),e._v(" "),v("p",[e._v("补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。")]),e._v(" "),v("h3",{attrs:{id:"_3、缓冲内存"}},[e._v("3、缓冲内存")]),e._v(" "),v("p",[e._v("缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。")]),e._v(" "),v("h3",{attrs:{id:"_4、内存碎片"}},[e._v("4、内存碎片")]),e._v(" "),v("p",[e._v("内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。")]),e._v(" "),v("p",[e._v("内存碎片的产生与对数据进行的操作、数据的特点等都有关；此外，与使用的内存分配器也有关系：如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。后面将要说到的jemalloc便在控制内存碎片方面做的很好。")]),e._v(" "),v("p",[e._v("如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。")]),e._v(" "),v("h2",{attrs:{id:"三、redis数据存储的细节"}},[e._v("三、Redis数据存储的细节")]),e._v(" "),v("h3",{attrs:{id:"_1、概述"}},[e._v("1、概述")]),e._v(" "),v("p",[e._v("关于Redis数据存储的细节，涉及到内存分配器（如jemalloc）、简单动态字符串（SDS）、5种对象类型及内部编码、redisObject。在讲述具体内容之前，先说明一下这几个概念之间的关系。")]),e._v(" "),v("p",[e._v("下图是执行set hello world时，所涉及到的数据模型。")]),e._v(" "),v("p",[v("img",{attrs:{src:"/img/redis01.png",alt:""}})]),e._v(" "),v("p",[e._v("1）dictEntry：Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。")]),e._v(" "),v("p",[e._v("（2）Key：图中右上角可见，Key（”hello”）并不是直接以字符串存储，而是存储在SDS结构中。")]),e._v(" "),v("p",[e._v("（3）redisObject：Value(“world”)既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论Value是5种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。")]),e._v(" "),v("p",[e._v("实际上，redisObject除了type和ptr字段以外，还有其他字段图中没有给出，如用于指定对象内部编码的字段；后面会详细介绍。")]),e._v(" "),v("p",[e._v("（4）jemalloc：无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。")]),e._v(" "),v("p",[e._v("下面来分别介绍jemalloc、redisObject、SDS、对象类型及内部编码。")]),e._v(" "),v("h3",{attrs:{id:"_2、jemalloc"}},[e._v("2、jemalloc")]),e._v(" "),v("p",[e._v("Redis在编译时便会指定内存分配器；内存分配器可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。")]),e._v(" "),v("p",[e._v("jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。")]),e._v(" "),v("h2",{attrs:{id:"_1-redis-基本操作"}},[e._v("1 Redis 基本操作")]),e._v(" "),v("h3",{attrs:{id:"_1-1-set-key-value-ex-seconds-px-milliseconds-nx-xx"}},[e._v("1.1 "),v("code",[e._v("SET key value [EX seconds] [PX milliseconds] [NX|XX]")])]),e._v(" "),v("p",[e._v("支持过时失效的设置；"),v("br"),e._v("\n我们说几个常见的应用场景：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("验证码"),v("br"),e._v("\n我们经常在登录一些网站或是进行付款等操作的时候，都会收到一些验证码，并且说10min后失效。\n实际上就可以通过下面一条指令来实现："),v("br"),e._v(" "),v("code",[e._v("set phone_num code ex 600")]),v("br"),e._v("\n用手机号作为key，验证码作为值，超时6min。这样当你输入好验证码，提交的时候，后台就可以了先get phone_num，再比较你的输入和数据库里面存的值，从而完成身份的验证。")])]),e._v(" "),v("li",[v("p",[e._v("session"),v("br"),e._v("\n早前，网站通过cookie来保存用户的用户名和密码，之后出现了很多的安全隐患，因此就提出了session的机制。\n用户登陆成功之后，本地的cookie会保留一个较长的随机码，而网站后的后台则存储了这个随机码和你的用户id的对应关系。在你第二次登录的时候，cookie会传输到后台，而后台则根据你的随机码，获取你的用户信息，  如果符合，则自动登录。这样，即使网站上有不法分子获取了你的cookie，也得不到你的任何信息，因为你的真实的有用的信息都存储在网站的后台。"),v("br"),e._v("\n我们在登录邮箱的时候，通常都会有一个选项，7天内自动登录。这其实就是给后台存的session设置了一个超时。聪明的你是不是已经会自己实现了呢？")])])]),e._v(" "),v("h3",{attrs:{id:"_1-2-setrange-key-offset-value"}},[e._v("1.2 "),v("code",[e._v("SETRANGE key offset value")])]),e._v(" "),v("p",[e._v("这个命令可以覆盖掉key对应的string的一部分。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('redis> set str "hello world"\nOK\nredis> setrange str 6 redis\n(integer) 11\nredis> get str\n"hello redis"\nredis> setrange str 15 aha\n(integer) 18\nredis> get str\n"hello redis\\x00\\x00\\x00\\x00aha"\nredis> del str\n(integer) 1\nredis> setrange str 5 "hello miao"\n(integer) 15\nredis> get str\n"\\x00\\x00\\x00\\x00\\x00hello miao"\n')])])]),v("p",[e._v('在这个实验中，我们先新建了一个str，内容是"hello world"，之后，从位置6开始写入字符串"redis"，则得到了"hello redis"。之后我们在15的位置，写入"aha"，这是offset已经比字符串的长度要大了，则Redis会默认填充0（\\x00是0的16进制表达），之后再追加字符串。最后，我们给一个不存在的key使用setrange设置了一个值，结果表现得和空字符串一样。')]),e._v(" "),v("h3",{attrs:{id:"_1-3-mset-key-value-key-value"}},[e._v("1.3 "),v("code",[e._v("MSET key value [key value ...]")])]),e._v(" "),v("p",[e._v("一次性设置多个key-value。如果key的值已存在，则会直接覆盖。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('redis> mset name1 miaoerduo name2 miao name3 love\nOK\nredis> get name1\n"miaoerduo"\nredis> get name2\n"miao"\nredis> get name3\n"love"\n')])])]),v("h2",{attrs:{id:"_2-redis-持久化"}},[e._v("2. Redis 持久化")]),e._v(" "),v("p",[e._v("RDB持久化的触发分为手动触发和自动触发两种。")]),e._v(" "),v("ul",[v("li",[e._v("手动触发")])]),e._v(" "),v("p",[v("code",[e._v("save")]),e._v("命令和"),v("code",[e._v("bgsave")]),e._v("命令都可以生成RDB文件。")]),e._v(" "),v("p",[e._v("save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。")]),e._v(" "),v("p",[e._v("而bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。")]),e._v(" "),v("p",[e._v("bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用；后文中也将只介绍bgsave命令。此外，在自动触发RDB持久化时，Redis也会选择bgsave而不是save来进行持久化；下面介绍自动触发RDB持久化的条件。")]),e._v(" "),v("ul",[v("li",[e._v("自动触发")])]),e._v(" "),v("p",[v("code",[e._v("save m n")])]),e._v(" "),v("p",[e._v("自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。")]),e._v(" "),v("p",[e._v("例如，查看redis的默认配置文件(Linux下为redis根目录下的redis.conf)，可以看到如下配置信息：")]),e._v(" "),v("p",[e._v("其中save 900 1的含义是：当时间到900秒时，如果redis数据发生了至少1次变化，则执行bgsave；save 300 10和save 60 10000同理。当三个save条件满足任意一个时，都会引起bgsave的调用。")]),e._v(" "),v("h2",{attrs:{id:"_3-redis-数据恢复顺序"}},[e._v("3.Redis 数据恢复顺序")]),e._v(" "),v("p",[e._v("前面提到过，当AOF开启时，Redis启动时会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会载入RDB文件恢复数据。")]),e._v(" "),v("h2",{attrs:{id:"_4-aof常用配置总结"}},[e._v("4. AOF常用配置总结")]),e._v(" "),v("p",[e._v("下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('appendonly no：是否开启AOF\nappendfilename "appendonly.aof"：AOF文件名\ndir ./：RDB文件和AOF文件所在目录\nappendfsync everysec：fsync持久化策略\nno-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡\nauto-aof-rewrite-percentage 100：文件重写触发条件之一\nauto-aof-rewrite-min-size 64mb：文件重写触发提交之一\naof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件\n')])])]),v("h2",{attrs:{id:"_5-方案选择与常见问题"}},[e._v("5. 方案选择与常见问题")]),e._v(" "),v("h3",{attrs:{id:"_5-1-rdb和aof的优缺点"}},[e._v("5.1 RDB和AOF的优缺点")]),e._v(" "),v("h4",{attrs:{id:"rdb持久化"}},[e._v("RDB持久化")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。")])]),e._v(" "),v("li",[v("p",[e._v("缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。")])])]),e._v(" "),v("h4",{attrs:{id:"aof持久化"}},[e._v("AOF持久化")]),e._v(" "),v("ul",[v("li",[e._v("优点：与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好")]),e._v(" "),v("li",[e._v("缺点：是文件大、恢复速度慢、对性能影响大。")])]),e._v(" "),v("h3",{attrs:{id:"_5-2-持久化策略选择"}},[e._v("5.2 持久化策略选择")]),e._v(" "),v("p",[e._v("在介绍持久化策略之前，首先要明白无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题（后面会详细介绍这种阻塞），此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。")]),e._v(" "),v("p",[e._v("在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用RDB或AOF的一种，或同时开启RDB和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。")]),e._v(" "),v("p",[e._v("下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。")]),e._v(" "),v("p",[e._v("（1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。")]),e._v(" "),v("p",[e._v("（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。")]),e._v(" "),v("p",[e._v("（3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。")]),e._v(" "),v("p",[e._v("在这种情况下，一种可行的做法是：")]),e._v(" "),v("p",[e._v("master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好")]),e._v(" "),v("p",[e._v("slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。")]),e._v(" "),v("p",[e._v("这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：")]),e._v(" "),v("p",[e._v("master和slave进程同时停止：考虑这样一种场景，如果master和slave在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失。"),v("br"),e._v("\nmaster误重启：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵(关于哨兵后面会有文章介绍)进行自动的主从切换，也有可能在哨兵轮询到master之前，便被自动拉起机制重启了。因此，应尽量避免“自动拉起机制”和“不做持久化”同时出现。")]),e._v(" "),v("p",[e._v("（4）异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。")]),e._v(" "),v("h2",{attrs:{id:"_6-总结"}},[e._v("6. 总结")]),e._v(" "),v("p",[e._v("本文主要内容可以总结如下：")]),e._v(" "),v("p",[e._v("1、持久化在Redis高可用中的作用：数据备份，与主从复制相比强调的是由内存到硬盘的备份。")]),e._v(" "),v("p",[e._v("2、RDB持久化：将数据快照备份到硬盘；介绍了其触发条件（包括手动出发和自动触发）、执行流程、RDB文件等，特别需要注意的是文件保存操作由fork出的子进程来进行。")]),e._v(" "),v("p",[e._v("3、AOF持久化：将执行的写命令备份到硬盘（类似于MySQL的binlog），介绍了其开启方法、执行流程等，特别需要注意的是文件同步策略的选择（everysec）、文件重写的流程。")]),e._v(" "),v("p",[e._v("4、一些现实的问题：包括如何选择持久化策略，以及需要注意的fork阻塞、AOF追加阻塞等。")])])}),[],!1,null,null,null);s.default=t.exports}}]);